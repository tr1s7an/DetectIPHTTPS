#!/usr/bin/env python

import ssl
import socket
import ipaddress
import concurrent.futures


class DetectIPHTTPS:

    def __init__(self, a: int, b: int) -> None:
        self.headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:97.0) Gecko/20100101 Firefox/97.0'}
        self.ipset = f'{a}.{b}.%d.%d'
        self.results_file = 'results/' + self.ipset
        self.default_hostname = 'www.cloudflare.com'
        self.max_threads = 16
        self.max_processes = 16

    def start_threads(self, c: int) -> list:
        results = []
        context = ssl.SSLContext(protocol=ssl.PROTOCOL_TLS_CLIENT)
        context.check_hostname = False
        context.load_default_certs()
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            future_to_url = {executor.submit(self.detect, c, d, context): d for d in range(0, 256)}
            for future in concurrent.futures.as_completed(future_to_url):
                result = future.result()
                if len(result) > 1:
                    results.append(result)
        return results

    def detect(self, c: int, d: int, context: ssl.SSLContext) -> list:
        this_ip = self.ipset % (c, d)
        namelist = [this_ip]
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:
            with context.wrap_socket(sock, server_hostname=self.default_hostname) as conn:
                try:
                    conn.connect((this_ip, 443))
                    cert = conn.getpeercert()
                    for each in cert['subjectAltName']:
                        namelist.append(each[1])
                except Exception:
                    pass
        return namelist

    def write_to_file(self, results_dict: dict) -> None:
        sorted_keys = sorted(results_dict.keys(), key=ipaddress.IPv4Address)
        with open(self.results_file, 'w') as f:
            f.write('=====Generated by Github Actions=====\n')
            for key in sorted_keys:
                f.write(key)
                f.write(' ')
                f.write(results_dict[key])
                f.write('\n')

    def start_processes(self) -> None:
        results = []
        results_dict = {}
        with concurrent.futures.ProcessPoolExecutor(max_workers=self.max_processes) as executor:
            for results in executor.map(self.start_threads, range(0, 256)):
                for result in results:
                    results_dict[result[0]] = ' '.join(result[1:])
        self.write_to_file(results_dict)


if __name__ == '__main__':
    socket.setdefaulttimeout(2)
    # detect 202.81.0.0/16
    mydetect = DetectIPHTTPS(202, 81)
    mydetect.start_processes()
